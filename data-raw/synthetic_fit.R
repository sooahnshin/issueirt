## Synthetic data
## See vignette("dynamic_issueirt") for more details

library(issueirt)
synth_data <- generate_data(seed = 02138,
                            n = 100,
                            m = 150,
                            k = 6,
                            kappa = 12,
                            rho = 15,
                            a = 0.01,
                            b = 0.001,
                            theta = 0:5 * pi/6)

## helper function to visualize the synthetic data
library(tidyverse)
theme_set(theme_classic(base_size = 15) + theme(legend.position = "bottom", plot.title = element_text(hjust = 0.5)))

#' function to create group assignment
#' in case of real data, you may use the party id, etc.
#' @param synth_data a list object generated by generate_data
#' @param legis_id a character vector of legislator id
#' @return a tibble
create_group <- function(synth_data, legis_id) {
  df <- synth_data$data$X |>
    as_tibble() |>
    mutate(id = legis_id) |>
    mutate(
      # Determine the threshold for top 30% of V2
      top_30_percent_V2 = quantile(V2, 0.7, type = 7),  # Adjust 'type' as necessary
      group = case_when(
        V2 > top_30_percent_V2 ~ "C",  # Assign Group C for top 30% of V2
        TRUE ~ NA_character_  # Temporarily fill others with NA
      )
    ) |>
    # Now, assign Groups A and B for the remaining using V1
    mutate(
      group = if_else(is.na(group),  # Only assign A or B if not already in C
                      case_when(
                        V1 <= median(V1[is.na(group)]) ~ "A",  # Bottom 50% of remaining in V1
                        TRUE ~ "B"  # Top 50% of remaining in V1
                      ),
                      group  # Keep existing group assignment for C
      )
    ) |>
    select(-top_30_percent_V2)
  return(df)
}

## assign legis/bill id
legis_id <- paste0("legis", 1:dim(synth_data$data$Y)[1])
bill_id <- paste0("bill", 1:dim(synth_data$data$Y)[2])
true_legis <- create_group(synth_data, legis_id)

## visualize the synthetic data
plot_ideal(ideal_point_1d = true_legis$V1, true_legis$V2,
           group = true_legis$group, p.title = "True Ideal Points",
           breaks.group = c("A", "B", "C"), values.shape = c(17,18,19), values.color = c("indianred", "steelblue", "darkgreen"))

## data.frame containing id and group information
raw_legis <- true_legis |>
  select(id, group)
raw_bills <- tibble(id = bill_id)
rc <- pscl::rollcall(synth_data$data$Y,
                     yea = 1, nay = 0, missing = NA,
                     legis.names = raw_legis$id, legis.data = raw_legis,
                     vote.names = raw_bills$id, vote.data = raw_bills)

## drop (1) unanimous votes and (2) legislators with marginal amount of votes (< 20)
## update data.frame with filtered votes and legislators
filtered <- filter_votes(rc, lop = 0, minvotes = 20)
bills <- raw_bills[filtered$bills,]
legis <- raw_legis[filtered$legis,]
votes <- rc$votes[filtered$legis, filtered$bills]

rc_input <- pscl::rollcall(votes, # original votes that are not recoded
                           yea = 1, nay = 0, missing = NA,
                           legis.names = legis$id, legis.data = legis,
                           vote.names = bills$id, vote.data = bills)

## fit the Bayesian IRT model
set.seed(1)
ideal <- pscl::ideal(rc_input, dropList = list(lop = 0, legisMin = 0), # no need to further drop votes and legislators
                     priors = NULL, startvals = "eigen", # default priors and starting values
                     d = 2, maxiter = 5000, thin = 1, burnin = 4800,
                     impute = FALSE, normalize = FALSE,
                     store.item = TRUE, file = NULL, verbose = FALSE)

pol_rc1 <- find_pol_rc_horizontal(rc_input, party_code_col = "group", liberal_code = "A", conservative_code = "B", na_threshold = 0.3)
pol_rc2 <- find_pol_rc_vertical(ideal, rc_input, pol_rc1, party_code_col = "group", na_threshold = 0.3, lop_threshold = 0.1)

const_ls <- find_constraints(ideal, rc_input, pol_rc1 = pol_rc1, pol_rc2 = pol_rc2, party_code_col = "group", left_party_code = "A", top_party_code = "C", as_list = TRUE)
print(const_ls)

## suppress redundant messages
invisible(capture.output({
  ideal_pp <- pscl::postProcess(ideal, constraints = const_ls)
}))

plot_ideal(ideal_point_1d = ideal_pp$xbar[,1], ideal_point_2d = ideal_pp$xbar[,2],
           group = legis$group, p.title = "BIRT Estimates of Ideal Points",
           breaks.group = c("A", "B", "C"), values.shape = c(17,18,19), values.color = c("indianred", "steelblue", "darkgreen"))

## make character issue code for an illustration
synth_issue_code <- as.character(synth_data$stan$z)
synth_issue_level <- as.character(unique(sort(synth_data$stan$z)))
## make issue code
issue_code <- make_issue_code(issue_code_vec = synth_issue_code, levels = synth_issue_level)

stan_input <- make_stan_input(
  issue_code_vec = issue_code$issue_code_vec, # user-supplied issue labels
  rollcall = rc_input, # rollcall object
  ideal = ideal_pp, # starting values
  a = 0.01, b = 0.001, rho_init = 10 # hyperparameters
)

fit_sim <- issueirt_stan(
  data = stan_input$data,
  init = list(stan_input$init, stan_input$init), # starting values
  chains = 2,             # number of Markov chains
  warmup = 10,            # number of warmup iterations per chain
  iter = 20,              # total number of iterations per chain
  cores = 2,              # number of cores (could use one per chain)
  seed = 1
)

## save
usethis::use_data(fit_sim, synth_data, overwrite = TRUE, internal = TRUE)
